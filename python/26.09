##бинарная куча
import heapq

a = [8,3,5,1,6,2,4,7]
heapq.heapify(a)
heapq.heappush(a, 0)
min_val = heapq.heappop(a)

##биномиальная куча
class BNode:
    def __init__(self, key):
        self.key = key
        self.child = None
        self.sibling = None
        self.parent = None
        self.degree = 0

class BinomialHeap:
    def __init__(self):
        self.head = None  # head of root list

    # объединение корневых списков по возрастанию degree
    def _merge_root_lists(self, h1, h2):
        # возвращает head объединённого списка
        pass

    def union(self, other):
        # merge + проход по списку, связывание деревьев одинаковой степени
        pass

    def insert(self, key):
        newh = BinomialHeap()
        newh.head = BNode(key)
        self.union(newh)

##куча Фибоначчи
class FNode:
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.child = None
        self.left = self
        self.right = self
        self.degree = 0
        self.mark = False

class FibonacciHeap:
    def __init__(self):
        self.min = None
        self.n = 0

    def insert(self, key):
        node = FNode(key)
        if self.min is None:
            self.min = node
        else:
            # insert node into root list (right of min)
            node.right = self.min.right
            node.left = self.min
            self.min.right.left = node
            self.min.right = node
            if node.key < self.min.key:
                self.min = node
        self.n += 1
        return node

    def find_min(self):
        return self.min.key if self.min else None

    # extract_min и decrease_key — более длинные процедуры (с консолидированием и cascading cut)
##хеш-таблица
class HashTableChain:
    def __init__(self, capacity=16):
        self.table = [[] for _ in range(capacity)]
        self.capacity = capacity

    def _hash(self, key):
        return hash(key) % self.capacity

    def put(self, key, value):
        i = self._hash(key)
        for idx, (k, v) in enumerate(self.table[i]):
            if k == key:
                self.table[i][idx] = (key, value)
                return
        self.table[i].append((key, value))

    def get(self, key):
        i = self._hash(key)
        for k, v in self.table[i]:
            if k == key: return v
        raise KeyError(key)
